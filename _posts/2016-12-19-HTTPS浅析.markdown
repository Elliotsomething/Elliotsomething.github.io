---
layout:     post
title:      "HTTPS深入理解"
subtitle:   "HTTPS Learning"
date:       2016-12-19
author:     "Elliot"
header-img: "img/post-bg-ios9-web.jpg"
catalog:    true
tags:
    - iOS
    - HTTPS
    - SSL
---

**版权声明：本文为博主原创文章，未经博主允许不得转载；如需转载，请保持原文链接。**

本文旨在理解HTTPS的三次握手过程。

### 前提

#### 先了解一下HTTP的握手过程

HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。

TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。通常HTTP请求是使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议来传输数据；

下面的图表试图显示不同的TCP/IP和其他的协议在最初OSI（Open System Interconnect）模型中的位置：

<img src="https://Elliotsomething.GitHub.io/images/post-CoreData-01.png">

该图来自网络

HTTP的握手过程也就是TCP的握手过程，使用三次TCP握手确认建立一个HTTP连接。

**这个简单介绍一下TCP的三次握手：**

第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。


#### CA证书是什么？

CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。

CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。


### HTTPS和HTTP的区别

https协议需要到ca申请证书或自制证书。

http的信息是明文传输，https则是具有安全性的ssl加密。

http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。

http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。


### HTTPS握手过程

HTTPS协议在HTTP的基础上加入了SSL协议，SSL依靠证书来验证身份；

**注：验证身份可以是只验证服务器的身份，也可以是双方互相验证身份；取决于双方是否携带证书**

#### 验证服务器的握手过程

<img src="https://Elliotsomething.GitHub.io/images/post-SSL-01.png">
该图来自网络

(1) 客户端通过`Client Hello`消息将它支持的SSL版本、加密算法、密钥交换算法、MAC算法等信息发送给SSL服务器。

(2) 服务器确定本次通信采用的版本和加密套件，并通过`Server Hello`消息通知给客户端。如果服务器允许客户端在以后的通信中重用本次会话，则服务器会为本次会话分配会话ID，并通过`Server Hello`消息发送给SSL客户端。

(3) 服务器将携带自己公钥信息的数字证书通过`Certificate`消息发送给客户端。

(4) 服务器发送`Server Hello Done`消息，通知客户端版本和加密套件协商结束，开始进行密钥交换。

(5) 客户端验证服务器的证书合法后，利用证书中的公钥加密客户端随机生成的`premaster secret`，并通过`Client Key Exchange`消息发送给SSL服务器。

(6) 客户端发送`Change Cipher Spec`消息，通知服务器后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。

(7) 客户端计算已交互的握手消息（除`Change Cipher Spec`消息外所有已交互的消息）的Hash值，利用协商好的密钥和加密套件处理`Hash`值（计算并添加MAC值、加密等），并通过`Finished`消息发送给服务器。服务器利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。

(8) 同样地，SSL服务器发送`Change Cipher Spec`消息，通知客户端后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。

(9) 服务器计算已交互的握手消息的`Hash`值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过`Finished`消息发送给客户端。客户端利用同样的方法计算已交互的握手消息的Hash值，并与`Finished`消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。

(10) 客户端接收到服务器发送的`Finished`消息后，如果解密成功，则可以判断服务器是数字证书的拥有者，即服务器身份验证成功，因为只有拥有私钥的服务器才能从`Client Key Exchange`消息中解密得到`premaster secret`，从而间接地实现了客户端对服务器的身份验证。

**注：**

 `Change Cipher Spec`消息属于SSL密码变化协议，其他握手过程交互的消息均属于SSL握手协议，统称为SSL握手消息。

 计算`Hash`值，指的是利用`Hash`算法（`MD5`或`SHA`）将任意长度的数据转换为固定长度的数据。

#### 验证服务器和客户端的握手过程

<img src="https://Elliotsomething.GitHub.io/images/post-SSL-02.png">
该图来自网络

客户端的身份验证是可选的，由服务器决定是否验证客户端的身份。如图中蓝色部分标识的内容所示，如果服务器验证客户端身份，则服务器和客户端除了交互“只验证服务器的SSL握手过程”中的消息协商密钥和加密套件外，还需要进行以下操作：

 (1) 服务器发送`Certificate Request`消息，请求客户端将其证书发送给服务器。

 (2) 客户端通过`Certificate`消息将携带自己公钥的证书发送给服务器。服务器验证该证书的合法性。

 (3) 客户端计算已交互的握手消息、主密钥的`Hash`值，利用自己的私钥对其进行加密，并通过`Certificate Verify`消息发送给SSL服务器。

 (4) 服务器计算已交互的握手消息、主密钥的`Hash`值，利用客户端证书中的公钥解密`Certificate Verify`消息，并将解密结果与计算出的Hash值比较。如果二者相同，则客户端身份验证成功。


#### 恢复原有会话的SSL握手过程

<img src="https://Elliotsomething.GitHub.io/images/post-SSL-03.png">
该图来自网络

 协商会话参数、建立会话的过程中，需要使用非对称密钥算法来加密密钥、验证通信对端的身份，计算量较大，占用了大量的系统资源。为了简化SSL握手过程，SSL允许重用已经协商过的会话，具体过程为：

 (1) 客户端发送`Client Hello`消息，消息中的会话ID设置为计划重用的会话的ID。

 (2) 服务器如果允许重用该会话，则通过在`Server Hello`消息中设置相同的会话ID来应答。这样，客户端和服务器就可以利用原有会话的密钥和加密套件，不必重新协商。

 (3) 客户端发送`Change Cipher Spec`消息，通知SSL服务器后续报文将采用原有会话的密钥和加密套件进行加密和MAC计算。

 (4) 客户端计算已交互的握手消息的`Hash`值，利用原有会话的密钥和加密套件处理`Hash`值，并通过`Finished`消息发送给SSL服务器，以便SSL服务器判断密钥和加密套件是否正确。

 (5) 同样地，服务器发送`Change Cipher Spec`消息，通知客户端后续报文将采用原有会话的密钥和加密套件进行加密和MAC计算。

 (6) 服务器计算已交互的握手消息的`Hash`值，利用原有会话的密钥和加密套件处理`Hash`值，并通过`Finished`消息发送给客户端，以便SSL客户端判断密钥和加密套件是否正确。


### 补充：

#### 随机数的生成：

首先客户端先发第一个随机数`N1`，然后服务器回了第二个随机数`N2`（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数`N3`（这个随机数被称为`Premaster secret`），客户端用数字证书的公钥进行非对称加密，发给服务器；

而服务器用只有自己知道的私钥来解密，获取第三个随机数。只有，服务端和客户端都有了三个随机数`N1+N2+N3`，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。

因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。

#### 加密套件的交换：

客户端把自身支持的一系列`Cipher Suite`（密钥算法套件，后文简称`Cipher`）[C1,C2,C3, …]发给服务器；

服务器接收到客户端的所有`Cipher`后，与自己支持的套件作对比，如果找到双方都支持的Cipher，则告知客户端；

客户端与服务器使用匹配的`Cipher`进行后续通信。如果服务器没有找到匹配的算法，客户端将给出错误信息。

**注：**

SSL自身发展到3.0版本。1999年该协议由ITEL接管，进行了标准化，改名为TLS。可以说，TLS 1.0就是SSL 3.1版本。目前TLS最新版本是1.2。


**参考:**[SSL技术白皮书](http://itdocument.com/991823332/)
